\documentclass[12pt]{article}

\usepackage{graphicx}
\usepackage{paralist}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{hhline}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{multicol}
\usepackage{url}
\usepackage[left = 3cm, right = 3cm, top = 3cm]{geometry}


\pagestyle {plain}
\pagenumbering{arabic}

\newcounter{stepnum}

%% Comments

\usepackage{color}


\title{%
    Requirements Specification\\
    \large Artificial Facial Aging through Deep Neural Networks}
\author{Jessica de Leeuw, Sam Cymbaluk,\\
    Jeff Gibson, and Fanping Jiang}

\begin {document}

\maketitle


\newpage

\section {Domain}
Authors: Jessica de Leeuw and Jeff Gibson\\

\medskip

\noindent The current method for artificially aging a face in missing persons cases is flawed. The ability to produce an accurate projection with a single picture of the missing person is a powerful solution to this problem. The goal is to implement an algorithm that successfully produces a realistic interpretation of the individuals aged face. \\

Stakeholders would be parties such as the government, and other law enforcement services. The generation of aged faces is useful for tasks such as searching for missing persons. The Canadian government currently employs forensic artists to manually create projections of a missing person at a specific age. Images are generated through drawing, and a significant amount of information (such as pictures of family members) is required about the missing person. The expectation would be that a single image is required as input, and a fairly accurate representation of that person aged a certain number of years would be outputted.\\

The main entities which the domain is comprised of are machine learning, big data, and the artificial aging of human faces.\\

A machine learning approach will be used to perform the process of artificial facial aging. To generate accurately aged faces, a conditional Generative Adversarial Neural Network (cGAN) must be trained on big data. The machine learning domain is greatly affected by this project, as it will be the first project publicly available that performs artificial aging. On a similar note, if this project can generate sufficiently accurate images, it will drastically improve upon current techniques. This would make it a possibility that this technique could become the industry standard for artificial aging of human faces.\\

\section {Functional Requirements}

\subsection {Machine Learning Training}

Author: Sam Cymbaluk\\

\medskip

\noindent Text goes here.\\


Stack(T)

\subsection* {Uses}

N/A

\subsection* {Syntax}

\subsubsection* {Exported Types}

\ {What should be written here?}

\subsubsection* {Exported Constants}

None

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | p{5cm} |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
new Stack & seq of T & Stack & none\\
\hline
push & T & Stack & none\\
\hline
pop & & Stack & out\_of\_range\\
\hline
top & & T & out\_of\_range\\
\hline
size & & $\mathbb{N}$ & \\
\hline
toSeq& & seq of T & \\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

$S$:  {What is the type of the state variable?}

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions \& Design Decisions}

\begin{itemize}
\item The Stack(T) constructor is called for each object instance before any
  other access routine is called for that object.  The constructor can only be
  called once.
\item Though the toSeq() method violates the essential property of the stack
  object, since this could be achieved by calling top and pop many times, this
  method is provided as a convenience to the client. In fact, it increases the
  property of separation of concerns since this means that the client does not
  have to worry about details of building their own sequence from the sequence
  of pops.
\end{itemize}

\subsubsection* {Access Routine Semantics}

new Stack($s$):
\begin{itemize}
\item transition: $S := s$

\item output: $\mathit{out} := \mathit{self}$
\item exception: none
\end{itemize}

\noindent push($e$):
\begin{itemize}
\item output: $out := \text{new Stack}(S\ ||\ \langle e \rangle)$
\item exception: none
\end{itemize}

\subsection {Data Storage}

Author: Jeff Gibson\\

\medskip

\noindent Text goes here.\\

Stack(T)

\subsection* {Uses}

N/A

\subsection* {Syntax}

\subsubsection* {Exported Types}

\ {What should be written here?}

\subsubsection* {Exported Constants}

None

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | p{5cm} |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
new Stack & seq of T & Stack & none\\
\hline
push & T & Stack & none\\
\hline
pop & & Stack & out\_of\_range\\
\hline
top & & T & out\_of\_range\\
\hline
size & & $\mathbb{N}$ & \\
\hline
toSeq& & seq of T & \\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

$S$:  {What is the type of the state variable?}

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions \& Design Decisions}

\begin{itemize}
\item The Stack(T) constructor is called for each object instance before any
  other access routine is called for that object.  The constructor can only be
  called once.
\item Though the toSeq() method violates the essential property of the stack
  object, since this could be achieved by calling top and pop many times, this
  method is provided as a convenience to the client. In fact, it increases the
  property of separation of concerns since this means that the client does not
  have to worry about details of building their own sequence from the sequence
  of pops.
\end{itemize}

\subsubsection* {Access Routine Semantics}

new Stack($s$):
\begin{itemize}
\item transition: $S := s$

\item output: $\mathit{out} := \mathit{self}$
\item exception: none
\end{itemize}

\noindent push($e$):
\begin{itemize}
\item output: $out := \text{new Stack}(S\ ||\ \langle e \rangle)$
\item exception: none
\end{itemize}

\subsection {Front-end Interface}

Author: Fanping Jiang\\

\medskip

\noindent Text goes here.\\

Stack(T)

\subsection* {Uses}

N/A

\subsection* {Syntax}

\subsubsection* {Exported Types}

\ {What should be written here?}

\subsubsection* {Exported Constants}

None

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | p{5cm} |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
new Stack & seq of T & Stack & none\\
\hline
push & T & Stack & none\\
\hline
pop & & Stack & out\_of\_range\\
\hline
top & & T & out\_of\_range\\
\hline
size & & $\mathbb{N}$ & \\
\hline
toSeq& & seq of T & \\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

$S$:  {What is the type of the state variable?}

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions \& Design Decisions}

\begin{itemize}
\item The Stack(T) constructor is called for each object instance before any
  other access routine is called for that object.  The constructor can only be
  called once.
\item Though the toSeq() method violates the essential property of the stack
  object, since this could be achieved by calling top and pop many times, this
  method is provided as a convenience to the client. In fact, it increases the
  property of separation of concerns since this means that the client does not
  have to worry about details of building their own sequence from the sequence
  of pops.
\end{itemize}

\subsubsection* {Access Routine Semantics}

new Stack($s$):
\begin{itemize}
\item transition: $S := s$

\item output: $\mathit{out} := \mathit{self}$
\item exception: none
\end{itemize}

\noindent push($e$):
\begin{itemize}
\item output: $out := \text{new Stack}(S\ ||\ \langle e \rangle)$
\item exception: none
\end{itemize}


\subsection {Machine Learning Inference}

Author: Jessica de Leeuw\\

\medskip

\noindent The machine learning inference is what provides the services to the client. It holds the value that the user wishes to obtain.\\

The ML Inference will consist of a back-end that handles the trained version of the machine learning model. It will provide the inference services to the front-end. The end-user will input an image that has never been seen before by the ML model, and the model will output a prediction based on its training. It is essentially an API that the front-end will call.\\

The API will take an image of a person, and return an image of that same person. If it is fully functional, it will return a face that has been aged by a certain amount of years.


\section{Non-Functional Requirements}

\subsection {Reliability}

Author: Jessica de Leeuw\\

\medskip

\noindent Text

\subsection {Accuracy of Results}

Author: Jessica de Leeuw\\

\medskip

\noindent Text

\subsection {Performance}

Author: Jessica de Leeuw\\

\medskip

\noindent Text

\subsection {Human-Computer Interface Issues}

Author: Fanping Jiang\\

\medskip

\noindent Text

\subsection {Physical Constraints}

Author: Jeff Gibson\\

\medskip

\noindent Text

\subsection {Portability Issues}

Author: Sam Cymbaluk\\

\medskip

\noindent Text

\section{Requirements for the Development \& Maintenance Process}

\subsection {Quality Control Procedures}

Author: Fanping Jiang\\

\medskip

\noindent Text

\subsection {Priorities of the Required Functions}

Author: Sam Cymbaluk\\

\medskip

\noindent Text

\subsection {Likely Changes to System Maintenance Procedures}

Author: Jeff Gibson\\

\medskip

\noindent Text

\end {document}
